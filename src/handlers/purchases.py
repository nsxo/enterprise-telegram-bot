"""
Enterprise Telegram Bot - Purchase & Billing Handlers

This module contains all purchase, billing, and payment-related functionality
including product displays, Stripe integration, and transaction management.
"""

import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
from telegram.constants import ParseMode

from src import database as db
from src import stripe_utils
from src import bot_utils

logger = logging.getLogger(__name__)


async def billing_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Enhanced /billing command with Stripe customer portal access.
    """
    user = update.effective_user
    logger.info(f"Billing command from user {user.id}")
    
    try:
        # Get user data
        user_data = db.get_user_dashboard_data(user.id)
        if not user_data:
            await update.message.reply_text("‚ùå User not found. Please use /start first.")
            return
        
        # Get billing information
        total_spent = user_data.get('total_spent_cents', 0) / 100
        total_purchases = user_data.get('total_purchases', 0)
        tier = user_data.get('tier_name', 'standard').title()
        
        billing_text = f"""
üí≥ **Billing & Account Management**

**üìä Account Summary:**
‚Ä¢ Total Spent: ${total_spent:.2f}
‚Ä¢ Total Purchases: {total_purchases}
‚Ä¢ Account Tier: {tier}

**üîß Billing Tools:**
‚Ä¢ Manage payment methods
‚Ä¢ View transaction history
‚Ä¢ Download invoices
‚Ä¢ Update billing information

**üí° Account Benefits:**
‚Ä¢ Automatic receipt emails
‚Ä¢ Purchase protection
‚Ä¢ Priority customer support
‚Ä¢ Flexible payment options
        """
        
        keyboard = [
            [
                InlineKeyboardButton("üí≥ Customer Portal", callback_data="billing_portal"),
                InlineKeyboardButton("üìä Purchase History", callback_data="purchase_history")
            ],
            [
                InlineKeyboardButton("üõí Buy More Credits", callback_data="show_products"),
                InlineKeyboardButton("üí∞ Check Balance", callback_data="show_balance")
            ],
            [
                InlineKeyboardButton("üìß Email Report", callback_data="email_report"),
                InlineKeyboardButton("üè† Main Menu", callback_data="user_menu")
            ]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_text(
            billing_text,
            reply_markup=reply_markup,
            parse_mode=ParseMode.MARKDOWN
        )
        
    except Exception as e:
        logger.error(f"Billing command failed for user {user.id}: {e}")
        await update.message.reply_text("‚ùå Error accessing billing. Please try again.")


async def show_products_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Enhanced product showcase with personalized recommendations.
    """
    query = update.callback_query
    user = query.from_user
    
    try:
        await query.answer()
        
        # Get user data for personalized recommendations
        user_data = db.get_user_dashboard_data(user.id)
        credits = user_data.get('message_credits', 0) if user_data else 0
        
        # Get available products
        products = db.get_all_products()
        if not products:
            await query.edit_message_text("‚ùå No products available at the moment.")
            return
        
        # Create personalized intro based on credit level
        if credits < 2:
            intro = "üö® **Running Low on Credits!**\n\nDon't miss out on our conversation. Choose a package below:"
        elif credits < 10:
            intro = "üí° **Top Up Your Credits**\n\nGreat timing to refill! Here are our popular options:"
        else:
            intro = "üõí **Credit Store**\n\nStock up for uninterrupted conversations:"
        
        # Build product showcase with enhanced presentation
        product_text = f"{intro}\n\n"
        
        # Group products by type for better presentation
        credit_products = [p for p in products if p.get('type') == 'credits' or not p.get('type')]
        unlimited_products = [p for p in products if p.get('type') == 'unlimited']
        
        if credit_products:
            product_text += "üí∞ **Credit Packages:**\n"
            for product in credit_products[:4]:  # Show top 4 credit products
                name = product['name']
                credits_amount = product['credits']
                price = product['price_cents'] / 100
                
                # Add value proposition
                if credits_amount == 10:
                    value = "‚ö° Quick Start"
                elif credits_amount == 25:
                    value = "üåü Popular Choice"
                elif credits_amount == 50:
                    value = "üíé Best Value"
                elif credits_amount >= 100:
                    value = "üèÜ Premium"
                else:
                    value = "üí∞ Basic"
                
                product_text += f"‚Ä¢ **{credits_amount} Credits** - ${price:.2f} {value}\n"
                product_text += f"  ‚îî ${price/credits_amount:.3f} per credit\n"
        
        if unlimited_products:
            product_text += "\nüéØ **Unlimited Plans:**\n"
            for product in unlimited_products[:2]:  # Show top 2 unlimited plans
                name = product['name']
                price = product['price_cents'] / 100
                duration = "24 hours"  # Assuming daily plans
                
                product_text += f"‚Ä¢ **{name}** - ${price:.2f}\n"
                product_text += f"  ‚îî Unlimited messages for {duration}\n"
        
        # Create keyboard with product options
        keyboard = []
        
        # Add credit package buttons
        for product in credit_products[:3]:  # Top 3 credit packages
            credits_amount = product['credits']
            price = product['price_cents'] / 100
            keyboard.append([
                InlineKeyboardButton(
                    f"üí≥ Buy {credits_amount} Credits (${price:.2f})",
                    callback_data=f"purchase_product_{product['stripe_price_id']}"
                )
            ])
        
        # Add unlimited plan buttons if available
        for product in unlimited_products[:1]:  # Top unlimited plan
            price = product['price_cents'] / 100
            keyboard.append([
                InlineKeyboardButton(
                    f"üéØ {product['name']} (${price:.2f})",
                    callback_data=f"purchase_product_{product['stripe_price_id']}"
                )
            ])
        
        # Add navigation buttons
        keyboard.extend([
            [
                InlineKeyboardButton("üí≥ Billing Portal", callback_data="billing_portal"),
                InlineKeyboardButton("üìä My Analytics", callback_data="show_analytics")
            ],
            [
                InlineKeyboardButton("üí∞ Check Balance", callback_data="show_balance"),
                InlineKeyboardButton("üè† Main Menu", callback_data="user_menu")
            ]
        ])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            product_text,
            reply_markup=reply_markup,
            parse_mode=ParseMode.MARKDOWN
        )
        
    except Exception as e:
        logger.error(f"Show products callback failed for user {user.id}: {e}")
        await query.edit_message_text("‚ùå Error loading products. Please try again.")


async def product_type_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle product type selection callback."""
    query = update.callback_query
    
    try:
        await query.answer()
        
        # Extract product type from callback data
        product_type = query.data.replace("product_type_", "")
        
        # Get products of specific type
        products = db.get_products_by_type(product_type)
        
        if not products:
            await query.edit_message_text(f"‚ùå No {product_type} products available.")
            return
        
        if product_type == "credits":
            type_text = "üí∞ **Credit Packages**\n\nChoose your credit package:"
        elif product_type == "unlimited":
            type_text = "üéØ **Unlimited Plans**\n\nUnlimited messaging for set periods:"
        else:
            type_text = f"üõí **{product_type.title()} Products**\n\nAvailable options:"
        
        keyboard = []
        for product in products:
            price = product['price_cents'] / 100
            if product_type == "credits":
                button_text = f"üí≥ {product['credits']} Credits (${price:.2f})"
            else:
                button_text = f"üí≥ {product['name']} (${price:.2f})"
            
            keyboard.append([
                InlineKeyboardButton(
                    button_text,
                    callback_data=f"purchase_product_{product['stripe_price_id']}"
                )
            ])
        
        # Add back button
        keyboard.append([
            InlineKeyboardButton("‚¨ÖÔ∏è Back to Products", callback_data="show_products")
        ])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            type_text,
            reply_markup=reply_markup,
            parse_mode=ParseMode.MARKDOWN
        )
        
    except Exception as e:
        logger.error(f"Product type callback failed: {e}")
        await query.edit_message_text("‚ùå Error loading product type.")


async def billing_portal_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle billing portal access callback.
    """
    query = update.callback_query
    user = query.from_user
    
    try:
        await query.answer("üîÑ Creating secure billing portal...")
        
        # Create Stripe customer portal session
        try:
            portal_url = stripe_utils.create_customer_portal_session(
                customer_email=user.username or f"user_{user.id}@telegram.bot"
            )
            
            portal_text = """
üí≥ **Secure Billing Portal**

Click the link below to access your secure billing portal where you can:

‚Ä¢ üìä View all transactions
‚Ä¢ üí≥ Update payment methods  
‚Ä¢ üìß Manage email preferences
‚Ä¢ üìÑ Download invoices
‚Ä¢ ‚ùå Cancel subscriptions

**üîí Security Note:**
This is a secure Stripe portal. Your payment information is protected by bank-level encryption.
            """
            
            keyboard = [
                [
                    InlineKeyboardButton("üí≥ Open Billing Portal", url=portal_url)
                ],
                [
                    InlineKeyboardButton("‚¨ÖÔ∏è Back to Billing", callback_data="show_products"),
                    InlineKeyboardButton("üè† Main Menu", callback_data="user_menu")
                ]
            ]
            
        except stripe_utils.StripeError as e:
            logger.error(f"Stripe portal creation failed: {e}")
            portal_text = """
‚ùå **Portal Temporarily Unavailable**

We're unable to create your billing portal right now. This might be because:

‚Ä¢ No previous purchases found
‚Ä¢ Temporary service issue  
‚Ä¢ Payment system maintenance

**Alternative Options:**
‚Ä¢ Contact support for billing assistance
‚Ä¢ Try again in a few minutes
‚Ä¢ Use direct purchase options below
            """
            
            keyboard = [
                [
                    InlineKeyboardButton("üõí Browse Products", callback_data="show_products"),
                    InlineKeyboardButton("üí∞ Check Balance", callback_data="show_balance")
                ],
                [
                    InlineKeyboardButton("üè† Main Menu", callback_data="user_menu")
                ]
            ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            portal_text,
            reply_markup=reply_markup,
            parse_mode=ParseMode.MARKDOWN
        )
        
    except Exception as e:
        logger.error(f"Billing portal callback failed for user {user.id}: {e}")
        await query.edit_message_text("‚ùå Error accessing billing portal. Please try again.")


async def purchase_product_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle product purchase callback with Stripe Checkout.
    """
    query = update.callback_query
    user = query.from_user
    
    try:
        await query.answer("üîÑ Preparing checkout...")
        
        # Extract Stripe price ID from callback data
        stripe_price_id = query.data.replace("purchase_product_", "")
        
        # Get product details
        product = db.get_product_by_stripe_price_id(stripe_price_id)
        if not product:
            await query.edit_message_text("‚ùå Product not found.")
            return
        
        # Create Stripe checkout session
        try:
            checkout_data = stripe_utils.create_checkout_session(
                price_id=stripe_price_id,
                customer_email=user.username or f"user_{user.id}@telegram.bot",
                metadata={
                    'telegram_user_id': str(user.id),
                    'telegram_username': user.username or '',
                    'product_credits': str(product.get('credits', 0))
                }
            )
            
            checkout_url = checkout_data['url']
            session_id = checkout_data['id']
            
            # Store pending purchase
            db.create_pending_purchase(
                user_id=user.id,
                stripe_session_id=session_id,
                stripe_price_id=stripe_price_id,
                amount_cents=product['price_cents'],
                credits=product.get('credits', 0)
            )
            
            credits_text = f" ‚Ä¢ **Credits:** {product['credits']}" if product.get('credits') else ""
            price = product['price_cents'] / 100
            
            checkout_text = f"""
üõí **Secure Checkout Ready**

**Product:** {product['name']}
**Price:** ${price:.2f}{credits_text}

Click below to complete your purchase using our secure Stripe checkout:

**üîí Payment Security:**
‚Ä¢ Bank-level encryption
‚Ä¢ PCI DSS compliant
‚Ä¢ No card details stored
‚Ä¢ Instant delivery

Your credits will be added automatically after payment!
            """
            
            keyboard = [
                [
                    InlineKeyboardButton("üí≥ Complete Purchase", url=checkout_url)
                ],
                [
                    InlineKeyboardButton("‚¨ÖÔ∏è Back to Products", callback_data="show_products"),
                    InlineKeyboardButton("‚ùå Cancel", callback_data="user_menu")
                ]
            ]
            
        except stripe_utils.StripeError as e:
            logger.error(f"Stripe checkout creation failed: {e}")
            checkout_text = """
‚ùå **Checkout Temporarily Unavailable**

We're unable to process purchases right now due to a temporary issue.

**What you can do:**
‚Ä¢ Try again in a few minutes
‚Ä¢ Contact support if the issue persists
‚Ä¢ Check our status page for updates

We apologize for the inconvenience!
            """
            
            keyboard = [
                [
                    InlineKeyboardButton("üîÑ Try Again", callback_data=f"purchase_product_{stripe_price_id}"),
                    InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="show_products")
                ]
            ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            checkout_text,
            reply_markup=reply_markup,
            parse_mode=ParseMode.MARKDOWN
        )
        
    except Exception as e:
        logger.error(f"Purchase product callback failed for user {user.id}: {e}")
        await query.edit_message_text("‚ùå Error preparing purchase. Please try again.")


# Quick Buy Callbacks
async def quick_buy_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle quick buy callbacks (quick_buy_10, quick_buy_25, etc.).
    """
    query = update.callback_query
    user = query.from_user
    
    try:
        await query.answer("üîÑ Setting up quick purchase...")
        
        # Extract amount from callback data
        amount = int(query.data.replace("quick_buy_", ""))
        
        # Find product with matching credit amount
        products = db.get_all_products()
        matching_product = None
        
        for product in products:
            if product.get('credits') == amount:
                matching_product = product
                break
        
        if not matching_product:
            await query.edit_message_text(
                f"‚ùå {amount}-credit package not available. Check our full product catalog."
            )
            return
        
        price = matching_product['price_cents'] / 100
        
        quick_buy_text = f"""
‚ö° **Quick Buy: {amount} Credits**

**üí∞ Price:** ${price:.2f}
**‚ö° Credits:** {amount}
**üí° Per Credit:** ${price/amount:.3f}

**‚ú® What's Included:**
‚Ä¢ Instant credit delivery
‚Ä¢ No subscription required
‚Ä¢ Same high-quality responses
‚Ä¢ 24/7 availability

Ready to purchase?
        """
        
        keyboard = [
            [
                InlineKeyboardButton(
                    f"üí≥ Buy Now (${price:.2f})",
                    callback_data=f"purchase_product_{matching_product['stripe_price_id']}"
                )
            ],
            [
                InlineKeyboardButton("üõí View All Options", callback_data="show_products"),
                InlineKeyboardButton("üí∞ Check Balance", callback_data="show_balance")
            ],
            [
                InlineKeyboardButton("‚ùå Cancel", callback_data="user_menu")
            ]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            quick_buy_text,
            reply_markup=reply_markup,
            parse_mode=ParseMode.MARKDOWN
        )
        
    except Exception as e:
        logger.error(f"Quick buy callback failed for user {user.id}: {e}")
        await query.edit_message_text("‚ùå Error processing quick buy. Please try again.")


# Purchase History Callbacks
async def refresh_history_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle refresh purchase history callback."""
    query = update.callback_query
    user = query.from_user
    
    try:
        await query.answer("üîÑ Refreshing purchase history...")
        
        # Get updated purchase history
        purchases = db.get_user_purchase_history(user.id, limit=10)
        
        if not purchases:
            history_text = """
üìã **Purchase History** *(Refreshed)*

No purchases found yet.

üéÅ **Get Started:**
‚Ä¢ New users get 3 free credits
‚Ä¢ First purchase often includes bonus credits
‚Ä¢ Regular promotions and discounts available

Ready to make your first purchase?
            """
            
            keyboard = [
                [
                    InlineKeyboardButton("üõí Browse Products", callback_data="show_products"),
                    InlineKeyboardButton("üí∞ Quick Buy 10", callback_data="quick_buy_10")
                ],
                [
                    InlineKeyboardButton("üè† Main Menu", callback_data="user_menu")
                ]
            ]
        else:
            # Calculate totals
            total_spent = sum(p.get('amount_cents', 0) for p in purchases) / 100
            total_credits = sum(p.get('credits_purchased', 0) for p in purchases)
            
            history_text = f"""
üìã **Purchase History** *(Refreshed)*

**üìä Summary:**
‚Ä¢ Total Spent: ${total_spent:.2f}
‚Ä¢ Total Credits: {total_credits:,}
‚Ä¢ Total Orders: {len(purchases)}

**üìù Recent Purchases:**
            """
            
            for purchase in purchases[:5]:  # Show last 5
                date = purchase.get('created_at', 'Unknown')
                amount = purchase.get('amount_cents', 0) / 100
                credits = purchase.get('credits_purchased', 0)
                status = purchase.get('status', 'unknown')
                
                status_emoji = {
                    'completed': '‚úÖ',
                    'pending': '‚è≥',
                    'failed': '‚ùå',
                    'refunded': 'üîÑ'
                }.get(status, '‚ùì')
                
                history_text += f"\n{status_emoji} **${amount:.2f}** ‚Ä¢ {credits} credits"
                if date != 'Unknown':
                    history_text += f" ‚Ä¢ {date[:10]}"
            
            keyboard = [
                [
                    InlineKeyboardButton("üìä Detailed History", callback_data="detailed_history"),
                    InlineKeyboardButton("üìß Email Report", callback_data="email_report")
                ],
                [
                    InlineKeyboardButton("üõí Buy More", callback_data="show_products"),
                    InlineKeyboardButton("üí∞ Check Balance", callback_data="show_balance")
                ],
                [
                    InlineKeyboardButton("üè† Main Menu", callback_data="user_menu")
                ]
            ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            history_text,
            reply_markup=reply_markup,
            parse_mode=ParseMode.MARKDOWN
        )
        
    except Exception as e:
        logger.error(f"Refresh history callback failed for user {user.id}: {e}")
        await query.edit_message_text("‚ùå Error refreshing purchase history.")


async def detailed_history_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle detailed purchase history callback."""
    query = update.callback_query
    user = query.from_user
    
    try:
        await query.answer()
        
        # Get comprehensive purchase history
        purchases = db.get_user_purchase_history(user.id, limit=20)
        
        if not purchases:
            await query.edit_message_text("üìã No purchase history available.")
            return
        
        # Create detailed history text
        history_text = "üìã **Detailed Purchase History**\n\n"
        
        for i, purchase in enumerate(purchases[:10], 1):  # Show top 10
            date = purchase.get('created_at', 'Unknown')
            amount = purchase.get('amount_cents', 0) / 100
            credits = purchase.get('credits_purchased', 0)
            status = purchase.get('status', 'unknown')
            transaction_id = purchase.get('stripe_payment_intent_id', 'N/A')
            
            status_emoji = {
                'completed': '‚úÖ',
                'pending': '‚è≥',
                'failed': '‚ùå',
                'refunded': 'üîÑ'
            }.get(status, '‚ùì')
            
            history_text += f"**{i}.** {status_emoji} ${amount:.2f} ‚Ä¢ {credits} credits\n"
            if date != 'Unknown':
                history_text += f"   üìÖ {date[:10]}\n"
            if transaction_id != 'N/A':
                history_text += f"   üîó ID: {transaction_id[:8]}...\n"
            history_text += "\n"
        
        keyboard = [
            [
                InlineKeyboardButton("üìß Email Full Report", callback_data="email_report"),
                InlineKeyboardButton("üîÑ Refresh", callback_data="refresh_history")
            ],
            [
                InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="purchase_history"),
                InlineKeyboardButton("üè† Main Menu", callback_data="user_menu")
            ]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            history_text,
            reply_markup=reply_markup,
            parse_mode=ParseMode.MARKDOWN
        )
        
    except Exception as e:
        logger.error(f"Detailed history callback failed for user {user.id}: {e}")
        await query.edit_message_text("‚ùå Error loading detailed history.")


async def email_report_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle email report callback."""
    query = update.callback_query
    user = query.from_user
    
    try:
        await query.answer("üìß Preparing email report...")
        
        report_text = """
üìß **Email Report Request**

**Feature Coming Soon!**

We're working on email reporting functionality that will include:

‚Ä¢ üìä Comprehensive purchase history
‚Ä¢ üí∞ Spending analytics  
‚Ä¢ üìà Usage statistics
‚Ä¢ üìÑ Downloadable PDF reports

**Current Options:**
‚Ä¢ Screenshot this conversation
‚Ä¢ Use the billing portal for invoices
‚Ä¢ Contact support for manual reports

Thank you for your patience!
        """
        
        keyboard = [
            [
                InlineKeyboardButton("üí≥ Billing Portal", callback_data="billing_portal"),
                InlineKeyboardButton("üìä View Analytics", callback_data="show_analytics")
            ],
            [
                InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="purchase_history"),
                InlineKeyboardButton("üè† Main Menu", callback_data="user_menu")
            ]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            report_text,
            reply_markup=reply_markup,
            parse_mode=ParseMode.MARKDOWN
        )
        
    except Exception as e:
        logger.error(f"Email report callback failed for user {user.id}: {e}")
        await query.edit_message_text("‚ùå Error preparing email report.") 