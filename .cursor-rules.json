{
  "metadata": {
    "projectName": "Enterprise Telegram Bot",
    "generatedBy": "Custom Rules for Telegram Bot Project",
    "generationDate": "2025-07-21T18:45:00.000Z",
    "ruleStructure": "custom",
    "appliedRuleSets": [
      "telegram-bot-specific",
      "flask-webhook-server",
      "postgresql-database",
      "stripe-payments",
      "python-best-practices",
      "enterprise-security"
    ]
  },
  "rules": [
    {
      "name": "Enterprise Telegram Bot Architecture",
      "description": "Core architectural guidelines for the Telegram bot project",
      "rule": "---\ndescription: Project-specific architecture and structure guidelines for the Enterprise Telegram Bot\nglobs: **/*.*\n---\n\n# Project Structure Requirements\n- Follow the defined folder structure: src/ for core logic, scripts/ for utilities, deployment/ for Docker configs\n- Use modular design with clear separation of concerns\n- Implement webhook-based real-time interactions, never long-polling\n- All components must be scalable, reliable, modular, and secure\n- Use Flask for webhook server with Gunicorn as WSGI server\n\n# Technology Stack\n- Python 3.11+ required\n- Flask for webhook endpoints\n- python-telegram-bot[ext] version 21.x+ for Telegram integration\n- PostgreSQL with psycopg2-binary for database\n- Stripe SDK for payment processing\n- python-dotenv for environment management\n- Docker for containerization and deployment\n\n# Code Organization\n- Keep all business logic in src/ directory\n- Database functions in src/database.py with connection pooling\n- Bot handlers and logic in src/bot.py\n- Configuration and environment variables in src/config.py\n- Global error handling in src/error_handler.py\n- Stripe utilities in src/stripe_utils.py\n- Flask webhook server in src/webhook_server.py",
      "examples": [],
      "source": "custom-telegram-bot-architecture"
    },
    {
      "name": "Telegram Bot Development Best Practices",
      "description": "Specific guidelines for python-telegram-bot development with local API reference",
      "rule": "---\ndescription: Best practices for Telegram bot development using python-telegram-bot library\nglobs: **/src/bot.py, **/src/*bot*.py\n---\n\n# Documentation Reference\n- Reference local Telegram API documentation in docs/telegram-api/\n- Use bot-api.html for official Telegram Bot API methods and types\n- Use python-telegram-bot-docs.html for library-specific implementation\n- Use forum-topics.html for topic management implementation details\n- See docs/telegram-api/README.md for quick reference commands\n\n# Handler Organization\n- Use CommandHandler for commands like /start, /balance, /billing\n- Use CallbackQueryHandler for inline keyboard callbacks\n- Use MessageHandler for conversation routing and topic management\n- Implement master_message_handler as primary message router\n- Use context.bot methods for all Telegram API calls\n\n# User Experience Guidelines\n- /start command should show welcome message with single \"▶️ Start\" button\n- /balance command should display credits with visual progress bar using create_progress_bar helper\n- /billing command should generate Stripe Customer Portal session links\n- Quick-buy commands (/buy10, etc.) should parse amount and initiate purchase\n- Always respond quickly to avoid Telegram timeouts\n\n# Topic-Based Conversation System\n- Implement get_or_create_user_topic function for admin conversation management\n- Use context.bot.create_forum_topic(chat_id=ADMIN_GROUP_ID, name=topic_name)\n- Forward user messages to dedicated topics in admin group (ADMIN_GROUP_ID)\n- Route admin replies from topics back to users using topic_id lookup\n- React with ✅ emoji using context.bot.set_message_reaction() to confirm delivery\n- Pin user info cards in new topics using send_user_info_card function\n\n# Error Handling\n- Use try-except blocks for all Telegram API calls\n- Implement proper error logging and user-friendly messages\n- Handle rate limiting and API timeouts gracefully\n- Use context.bot_data and context.user_data for state management",
      "examples": [],
      "source": "custom-telegram-bot-practices"
    },
    {
      "name": "Flask Webhook Server Guidelines",
      "description": "Flask-specific rules for webhook endpoints and server setup",
      "rule": "---\ndescription: Flask webhook server development guidelines for Telegram and Stripe webhooks\nglobs: **/src/webhook_server.py, **/src/*webhook*.py\n---\n\n# Documentation Reference\n- Reference docs/telegram-api/webhooks-guide.html for Telegram webhook best practices\n- Use docs/telegram-api/bot-api.html for Update object structure and handling\n- Follow webhook security guidelines from official Telegram documentation\n\n# Flask Application Structure\n- Use Flask application factory pattern for webhook server\n- Implement exactly three endpoints: /telegram-webhook, /stripe-webhook, /health\n- Always return appropriate HTTP status codes (200, 400, 403, 500)\n- Use JSON responses consistently\n\n# Telegram Webhook Endpoint (/telegram-webhook)\n- Accept POST requests with Telegram Update JSON payload\n- Deserialize to telegram.Update object immediately\n- Pass to python-telegram-bot Application instance for processing\n- Always return 200 OK quickly to avoid Telegram timeouts\n- Secure with secret token in webhook URL (long random string)\n- Follow HTTPS requirements as specified in webhooks-guide.html\n\n# Stripe Webhook Endpoint (/stripe-webhook)\n- CRITICAL: Always verify Stripe-Signature header against STRIPE_WEBHOOK_SECRET\n- Reject requests with invalid or missing signatures (403 Forbidden)\n- Handle checkout.session.completed for credit/time grants\n- Handle payment failures and disputes with admin notifications\n- Use proper error responses: 400 for malformed payload, 500 for processing errors\n\n# Health Check Endpoint (/health)\n- Simple GET endpoint returning {\"status\": \"healthy\"}\n- No authentication required\n- Used by hosting providers for service monitoring\n\n# Production Deployment\n- Use Gunicorn WSGI server for production\n- Configure proper logging and error handling middleware\n- Implement request timeout handling\n- Use environment variables for all configuration",
      "examples": [],
      "source": "custom-flask-webhook-server"
    },
    {
      "name": "PostgreSQL Database Management",
      "description": "Database best practices for PostgreSQL integration",
      "rule": "---\ndescription: PostgreSQL database management and connection handling best practices\nglobs: **/src/database.py, **/scripts/setup_db.py, **/docs/schema.sql\n---\n\n# Connection Management\n- CRITICAL: Use psycopg2.pool.SimpleConnectionPool for efficient connection management\n- Implement master execute_query function that acquires, uses, and releases connections\n- Always use connection pools instead of direct connections\n- Use try-finally blocks to ensure connections are released back to pool\n- Never leak database connections\n\n# Database Function Organization\n- Create specific, modular functions for all database operations\n- Implement get_user(user_id), update_user_credits(user_id, amount) functions\n- Use get_or_create_user for upsert operations with INSERT...ON CONFLICT\n- Implement conversation management functions: create_conversation_topic, get_user_id_from_topic\n- Use parameterized queries (%s) to prevent SQL injection\n\n# Schema Management\n- Maintain authoritative schema in docs/schema.sql\n- Use setup_db.py script to initialize database from schema file\n- Implement proper indexes for performance (topic_id, user_id, stripe_customer_id)\n- Use UUIDs for transaction IDs with uuid_generate_v4()\n- Enable required PostgreSQL extensions (uuid-ossp)\n\n# Data Integrity\n- Use CHECK constraints for data validation (message_credits >= 0)\n- Implement foreign key constraints for data relationships\n- Use proper timestamp fields with TIMESTAMPTZ\n- Create database views for business intelligence (user_dashboard_view)\n- Implement triggers for automatic timestamp updates\n\n# Performance Optimization\n- Create indexes on frequently queried columns\n- Use RETURNING clause in INSERT/UPDATE operations\n- Implement connection pooling with appropriate pool size\n- Use prepared statements for repeated queries",
      "examples": [],
      "source": "custom-postgresql-database"
    },
    {
      "name": "Stripe Payment Integration",
      "description": "Stripe SDK integration and payment processing guidelines",
      "rule": "---\ndescription: Stripe payment processing and webhook handling best practices\nglobs: **/src/stripe_utils.py, **/src/*stripe*.py, **/src/*payment*.py\n---\n\n# Stripe Utilities Organization\n- Centralize all Stripe API interactions in src/stripe_utils.py\n- Implement create_checkout_session(user_id, price_id) for purchases\n- Implement create_billing_portal_session(customer_id) for account management\n- Use environment variables for Stripe API keys and webhook secrets\n- Handle both test and production Stripe environments\n\n# Payment Flow Implementation\n- Create Stripe customers for all users with stripe_customer_id storage\n- Link products table with stripe_price_id for consistent pricing\n- Process checkout.session.completed events to grant credits/time\n- Handle payment failures with user notifications\n- Implement auto-recharge functionality with stored payment methods\n\n# Security Requirements\n- Always verify webhook signatures using Stripe-Signature header\n- Use STRIPE_WEBHOOK_SECRET for signature verification\n- Never trust webhook data without proper verification\n- Store sensitive Stripe data securely (customer IDs, not payment methods)\n- Log all payment events for audit trails\n\n# Error Handling\n- Handle Stripe API exceptions gracefully\n- Implement retry logic for transient failures\n- Process dispute and chargeback events\n- Send admin notifications for payment issues\n- Maintain transaction logs with status tracking\n\n# Product Management\n- Store product definitions in database with Stripe price IDs\n- Support multiple product types: credits, time access, premium content\n- Implement pricing in cents to avoid floating point issues\n- Handle subscription and one-time payment products\n- Enable/disable products through is_active flag",
      "examples": [],
      "source": "custom-stripe-integration"
    },
    {
      "name": "Python Best Practices for Enterprise Bot",
      "description": "Python coding standards specific to this bot project",
      "rule": "---\ndescription: Python coding best practices for enterprise Telegram bot development\nglobs: **/*.py\n---\n\n# Code Quality Standards\n- Follow PEP 8 style guide rigorously\n- Use type hints for all function signatures and return values\n- Write comprehensive docstrings for all functions and classes\n- Implement proper exception handling with specific exception types\n- Use descriptive variable and function names that explain purpose\n\n# Environment and Configuration\n- Use python-dotenv for environment variable management\n- Validate all environment variables at startup in src/config.py\n- Cast environment variables to appropriate types (int, bool)\n- Provide clear error messages for missing configuration\n- Never commit .env files or hardcode secrets\n\n# Error Handling and Logging\n- Implement comprehensive error handling in src/error_handler.py\n- Use Python logging module with appropriate log levels\n- Log all critical operations and errors with context\n- Handle database connection failures gracefully\n- Implement proper exception propagation and user feedback\n\n# Async Programming\n- Use async/await for I/O operations (database, HTTP requests)\n- Handle async context properly in bot handlers\n- Implement proper async database connections when needed\n- Use asyncio.gather for concurrent operations where appropriate\n\n# Testing and Reliability\n- Write unit tests for all critical functions\n- Test database operations with proper setup/teardown\n- Mock external services (Telegram, Stripe) in tests\n- Implement integration tests for webhook endpoints\n- Use pytest for testing framework",
      "examples": [],
      "source": "custom-python-best-practices"
    },
    {
      "name": "Enterprise Security and Deployment",
      "description": "Security and deployment guidelines for production environment",
      "rule": "---\ndescription: Security, containerization, and deployment best practices for enterprise bot\nglobs: **/deployment/**, **/*.dockerfile, **/Dockerfile, **/.env*, **/src/config.py\n---\n\n# Security Requirements\n- Use strong, randomly generated secrets for webhook URLs\n- Implement proper input validation and sanitization\n- Use parameterized database queries to prevent SQL injection\n- Validate and verify all webhook signatures\n- Never log sensitive data (tokens, keys, user data)\n- Implement rate limiting for bot interactions\n\n# Environment Configuration\n- Use environment variables for all configuration\n- Required variables: BOT_TOKEN, ADMIN_GROUP_ID, DATABASE_URL, STRIPE_API_KEY, STRIPE_WEBHOOK_SECRET\n- Validate all environment variables at startup\n- Use different configurations for development/production\n- Never commit environment files to version control\n\n# Docker Containerization\n- Use official python:3.11-slim base image in Dockerfile\n- Set appropriate working directory and user permissions\n- Copy requirements.txt first for better Docker layer caching\n- Install dependencies before copying source code\n- Use multi-stage builds for smaller production images\n- Set proper CMD to run Gunicorn server\n\n# Production Deployment\n- Use Gunicorn as WSGI server with proper worker configuration\n- Configure proper health checks for container orchestration\n- Implement proper logging configuration for production\n- Use connection pooling for database connections\n- Set up monitoring and alerting for critical operations\n- Implement graceful shutdown handling\n\n# Backup and Recovery\n- Implement database backup strategies\n- Store critical data with proper redundancy\n- Plan for disaster recovery scenarios\n- Document deployment and recovery procedures",
      "examples": [],
      "source": "custom-security-deployment"
    },
    {
      "name": "Clean Code Principles",
      "description": "General clean code guidelines for maintainability",
      "rule": "---\ndescription: Clean code principles for readable and maintainable code\nglobs: **/*.*\n---\n\n# Code Organization\n- Write functions that do exactly one thing (Single Responsibility Principle)\n- Keep functions small and focused (preferably under 20 lines)\n- Use meaningful names that explain purpose and behavior\n- Organize related code together in logical modules\n- Extract repeated code into reusable functions (DRY principle)\n\n# Code Clarity\n- Write self-documenting code that explains its purpose\n- Use comments to explain why, not what the code does\n- Avoid magic numbers - use named constants instead\n- Choose descriptive variable names over abbreviated ones\n- Structure code with consistent formatting and indentation\n\n# Error Handling\n- Handle errors at the beginning of functions (guard clauses)\n- Use early returns to avoid deeply nested conditionals\n- Implement proper exception handling with specific types\n- Provide meaningful error messages for debugging\n- Log errors with sufficient context for troubleshooting\n\n# Testing and Maintenance\n- Write tests for all critical functionality\n- Refactor code continuously to improve structure\n- Leave code cleaner than you found it\n- Use version control with meaningful commit messages\n- Document complex algorithms and business logic",
      "examples": [],
      "source": "custom-clean-code"
    }
  ]
}